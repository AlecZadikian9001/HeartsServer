Hearts Server Info:

Game Rule Notes:{
    The games are played with the standard rules of Hearts, but there are two rules the server follows that are sometimes disputed:
    1. Hearts will be considered broken if the Queen of Spades is played.
    2. If there are not 4 players, the lower Clubs besides the Two will be thrown out and will not be dealt out.
    
    It is up to your AI to follow the rules. The server validates each move. If your AI cheats, the tests for that group are stopped.
}

Cards:{
    When communicating with the server, your AI will need to know how cards are represented. Each card has a number. This is explained below.
    Suits are enumerated from 1 to 4 in this order: Hearts, Clubs, Diamonds, Spades.
    Ranks are enumerated from 1 to 13 starting with 2 and ending with Ace.
    Each card is represented as one integer = (suit*14 + rank). (This is a mixed radix conversion.)
    This means that you can get the suit of a card by dividing by 14 and rounding down, and you can get the rank of a card by modding by 14. I recommend that you implement macros or functions in your AI program to do this to provide a layer of abstraction!
    Example:{
        Four of Spades is represented by the number (suit_spades*14 + rank_4) = (4*14 + 3) = 59.
        floor(59/14) = 4 = suit_spades
        59%14 = 3 = rank_4
    }
    
    If it helps to see it, the C code on the server that deals with card definitions and parsing is pasted below:

            typedef enum{
                suit_start = 0, // Error, not an actual value but an open bound.
                suit_hearts,
                suit_clubs,
                suit_diamonds,
                suit_spades,
                suit_end // Error, not an actual value but an open bound.
            } Suit;
            typedef enum{
                rank_start = 0, // Error, not an actual value but an open bound.
                rank_2,
                rank_3,
                rank_4,
                rank_5,
                rank_6,
                rank_7,
                rank_8,
                rank_9,
                rank_10,
                rank_J,
                rank_Q,
                rank_K,
                rank_A,
                rank_end // Error, not an actual value but an open bound.
            } Rank;
            #define NULL_CARD (0)
            #define RANK_BASE (1)
            #define SUIT_BASE (rank_end)
            #define suitOf(card) ((int) (card / SUIT_BASE)) // If you're using C, you should make a macro like this...
            #define rankOf(card) (card % SUIT_BASE)         // ... and another like this...
            #define makeCard(suit, rank) (SUIT_BASE*RANK_BASE*suit + RANK_BASE*rank) // ... and one like this.
            
}

Communication at the Low Level:{
    You can write your AI in many different languages.
    The Hearts AI competition server communicates with AI programs through named pipes.
    If you aren't familiar with named pipes, check them out: http://en.wikipedia.org/wiki/Named_pipe 
    Basically, a named pipe "looks" like a file on a Unix system, but it's actually more like a stream of data.
    Whatever language you use should support reading and writing to/from named pipes.
    In C, you'd use the open() function defined in fcntl.h and read() and write() defined in unistd.h.
    In Java, you'd use a RandomAccessFile object and whatever methods that has.
    
    Now, there's a problem we need to address. Messages sent through pipes don't have "start" and "stop" markers. The server and client need to know when each message starts and stops.
    To solve this problem, each message is prepended with bytes representing the length of the message.
    Your client must know how to read such messages and must send messages with the length prepended.
    I may write functions/methods to do this in popular languages because it's quite difficult. I've only done it for C thus far.
    Currently, if you use C, you can use ctalk.h and ctalk.c (use cTalkSend() and cTalkRecv()) found here: https://github.com/AlecZadikian9001/libctalk/tree/master/libctalk
    This is exactly how the length is read in:{
        The length header is a variable-length quantity, represented by one OR MORE octet bytes.
        The octets are arranged with the least significant byte of the length quantity first.
        The leftmost bit of the octet tells the receiver whether or not there is another octet to be read (1 = yes, 0 = no).
        The remaining 7 bits of the octet contain the length, with the leftmost bit being the most significant as usual.
        If there's another octet to be read, its value should be multiplied by 128 to the power of the number of octets read in thus far minus 1 and then added to the length quantity.
    }
    If I haven't made this yet for the language you're using, don't worry about it. Just write a dummy function/method, and continue with your logic...
}

Communication at the High Level:{
    All messages to/from the server should be null-terminated strings. If you don't know what "null-terminated" means, you most likely don't have to worry about it.
    When all the AI players are being added in, the server sends the message "0" to all the clients.
    Your client should immediately respond to a "0" message with your AI's ASCII name of maximum length 15 characters (for example, "Moon Bot").
    The rounds then begin.
    The server shuffles and distributes the deck each round.
    Before each round starts, the server sends a message to your client with the character '3' followed immediately by the number of players in the game, the zero-indexed ID of your client, the ID of the player whose turn it is, then all the cards IN ORDER in your hand separated by commas (represented as integers as described above).
    This is the format: "3numPlayers,playerID,turn,card1,card2,card3,...cardN"
    Once your AI receives this message, it should keep these cards in an ordered array in the order they are sent by the server, NOT a list. The index of each card matters and must remain constant. Your AI should mark somehow which cards in its hand have already been played.
    Also, make sure your AI resets any variables left over from a previous round that need to be reset.
    The turns move in order of player ID, returning back to 0 each time, until the round is over.
    For example, in a 5-player game starting with player 2, it goes 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, ...
    The server then asks each AI for what card it wants to play by sending the message "1".
    Your AI should respond to the "1" message with the zero-starting index of the card (in its hand) that it wants to play, represented as a base-10 number in ASCII. (For example, "12" if it wants to play the 13th card in its hand).
    When a player plays a card, the server tells every player except the one that just played which player played and which card (integer representation) was played.
    The format of this is "2player,card" (Example: "23,34").
    Your AI does not have to respond immediately to this message, but it should make any necessary adjustments to its thinking, log the move, etc. before the server asks your AI for its move later on.
    After all the tricks in the hand have been played, the players' scores will be logged on the server, and a new round will begin. This will continue until the server has run many rounds and has accumulated a sum of the scores for each AI player.
    The server will send the message "4" to every client to tell each that testing has stopped. When your client receives the "4" message, it should stop its process (though this is not strictly necessary).
}
    
    
    
    
    
    
    


